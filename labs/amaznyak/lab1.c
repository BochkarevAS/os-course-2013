#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

void main() {
        
  pid_t pid, ppid;
  // форк возвращает id нового процесса, следовательно pid будет id нового процесса,
  // но сама переменная pid будет присутствовать в двух процессах, и в дочернем процесса
  // она будет равна 0.(вообще говоря, в дочернем процессе она не проинициалирована должна быть поидее).
  // Может так получиться что родительский процесс отработает и умрёт быстрее чем дочерний процесс выполнить getppid()
  // тогда его усыновит процесс linux и он скажет, что id моего отца равен 1. С помощью случайных чисел продемонстрирую это.
  srand(time(NULL));
  pid = fork();
  
  if (pid == -1) {
    
    printf("Не удалось форкнуться");
    exit(-1);
          
  } 
  else if (pid == 0) { //дочерний процесс 
	ppid = getppid(); // получаем id родительского процесса
	if(ppid == 1) {
		printf("\n Мой отец умер :( \n");
	}
	else{
		printf("\n Мой отец жив :) \n");
	}
    printf("Я сын мой id =%d, мой отец =%d \n", getpid(), ppid);
	
  } else {	// родительский процесс т.к. pid не равен 0.
    printf("Я отец мой id =%d, id моего сына =%d \n", getpid(), pid);
	int i = 0;
	int j = 1;
	while(i < j){
	j = rand();// в зависимости от случайных чисел отец может быстро выйти из цикла и умереть.
	i++;
	}
  }
  exit(0);
        
}
