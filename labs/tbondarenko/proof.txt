Алгоритм булочной.
1,2 - очевидно.
Пусть оба процесса оказались внутри своих критических секций.P[i] процесс может
 оказаться в критической области, если подождал пока какой-либо процесс P[j] 
зашел в while(some..) и изменил choose[j] = true, для того, чтобы взять себе номер.
P[i]зациклился, пока работает P[j], и номер P[i] -го или его номер имени не стал меньше, 
чем у P[j],т.е while(number[j]!=0  && (number[j],j)<(number[i],i)). Следовательно
чтобы 2-м процессам оказаться в критических областях надо чтобы 
(number[j],j)>(number[i],i) для i-того и
(number[i],i)>(number[j],j) для j-того, а это уже противоречие!Условие 3 выполняется.
Докажем выполнение условия прогресса.
Какой-нибудь прооцес P[j] зайдет в критическую область и у него будет,к примеру,
 number[j] = k.Другой процесс P[i] не сможет зайти в критическую облатсь 
т.к уже number[j]!=0 и номер P[i] взял позже, чем P[j]. Следовательно P[i] зациклится 
while(number[j]!=0  && (number[j],j)<(number[i],i)).А только когда number[j]=0, т.е P[j]
уйдет из критической секции, процесс P[i] сможет в нее зайти! Условие 4 выполняется.
Условие ограниченного ожидания тоже выполняется, т.к выполняются процессы по принципу 
очереди.Сначала минимальный номер потом +1 и т.д. Т.е вновь пришедший процесс не может
получить номер меньше чем у процесса, который получил номер раньше, следовательно и 
выполниться вновь пришедший процесс не сможет раньше, заставив этим ждать другой.
