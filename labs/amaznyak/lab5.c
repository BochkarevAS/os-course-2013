#include <sys/types.h>
#include <unistd.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>

// Измените программу в соответствие с заданием и переименуйте, чтобы еще и номер соответствовал тому что надо

int main(){

	int fd[2], result;
	size_t size;
	int res[5]; 

	/* Попытаемся создать pipe */

	if(pipe(fd) < 0){

		/* Если создать pipe не удалось, печатаем об этом сообщение и прекращаем работу */

		printf("Can\'t create pipe\n");
		exit(-1); 
	} 

	/* Порождаем новый процесс */ 

	result = fork(); 
	
	while (true) {
	
		if(result <0){ 

			/* Если создать процесс не удалось, сообщаем об этом и завершаем работу */

			printf("Can\'t fork child\n");
			exit(-1);

		} else if (result > 0) {

			/* Мы находимся в родительском процессе, который будет передавать информацию процессу-ребенку . В этом процессе выходной поток данных нам не понадобится, поэтому закрываем его.*/

			close(fd[0]);

			/* Пробуем записать случайное число */
			
			srand(time(NULL));
			chislo = rand();
			
			size = write(fd[1], chislo, 14);
			
			
			
			if(size != 14){

				/* Если записалось меньшее количество байт, сообщаем об ошибке и завершаем работу */

				printf("Can\'t write all string\n"); 
				exit(-1); 
			} 

			
			printf("Parent exit\n");

		} else {

			/* Мы находимся в порожденном процессе, который будет получать информацию от процесса-родителя. Он унаследовал от родителя таблицу открытых файлов и, зная файловые дескрипторы, соответствующие pip'у, может его использовать. В этом процессе входной поток данных нам не понадобится, поэтому закрываем его.*/

			//close(fd[1]);

			/* Пробуем прочитать из pip'а число*/

			size = read(fd[0], res[0], 14);

			if(size < 0){

			/* Если прочитать не смогли, сообщаем об ошибке и завершаем работу */

				printf("Can\'t read string\n"); 
				exit(-1); 
			} 

			/* Печатаем прочитанную строку */

			printf("%d \n",res[0]);

			

		}
	}
	/* Закрываем входной поток и завершаем работу */
	close(fd[0]);
	/* Закрываем входной поток данных и на этом родитель прекращает работу */
	close(fd[1]);
	
	return 0;
}
